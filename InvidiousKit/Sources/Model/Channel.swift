import Foundation

public struct Channel: Hashable, Decodable {
    public var author: String
    public var authorId: String
    public var authorUrl: String
    public var authorVerified: Bool
    public var authorBanners: [ImageObject]
    public var authorThumbnails: [ImageObject]
    public var subCount: Int
    public var totalViews: Int
    public var joined: Int
    public var autoGenerated: Bool
    public var isFamilyFriendly: Bool
    public var description: String
    public var descriptionHtml: String
    public var allowedRegions: [String]
    public var latestVideos: [VideoObject]
    public var relatedChannels: [ChannelObject]
    
    public static func == (lhs: Channel, rhs: Channel) -> Bool {
        lhs.authorId == rhs.authorId
    }
    
    public struct PlaylistResponse: Hashable, Decodable {
        public var playlists: [PlaylistObject]
        public var continuation: String?
        
        public static func == (lhs: Channel.PlaylistResponse, rhs: Channel.PlaylistResponse) -> Bool {
            lhs.continuation == rhs.continuation
        }
    }
    
    public struct VideosResponse: Hashable, Decodable {
        public var videos: [VideoObject]
        public var continuation: String?
        
        public static func == (lhs: Channel.VideosResponse, rhs: Channel.VideosResponse) -> Bool {
            lhs.continuation == rhs.continuation
        }
        
        enum CodingKeys: CodingKey {
            case videos
            case continuation
        }
        
        public init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<Channel.VideosResponse.CodingKeys> = try decoder.container(keyedBy: Channel.VideosResponse.CodingKeys.self)
            self.continuation = try container.decodeIfPresent(String.self, forKey: Channel.VideosResponse.CodingKeys.continuation)
            self.videos = (try? container.decode([VideoObject].self, forKey: Channel.VideosResponse.CodingKeys.videos))
                ?? []
        }
    }
}

public extension APIClient {
    func channel(for id: String) async throws -> Channel {
        guard let idPath = id.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) else {
            throw APIError.urlCreation
        }
        let (data, _) = try await request(for: "/api/v1/channels/\(idPath)")
        return try decoder.decode(Channel.self, from: data)
    }
    
    func videos(for channelId: String, continuation: String?) async throws -> Channel.VideosResponse {
        guard let idPath = channelId.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) else {
            throw APIError.urlCreation
        }
        let (data, _) = try await request(for: "/api/v1/channels/\(idPath)/videos")
        return try decoder.decode(Channel.VideosResponse.self, from: data)
    }
    
    func shorts(for channelId: String, continuation: String?) async throws -> Channel.VideosResponse {
        guard let idPath = channelId.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) else {
            throw APIError.urlCreation
        }
        let (data, _) = try await request(for: "/api/v1/channels/\(idPath)/shorts")
        return try decoder.decode(Channel.VideosResponse.self, from: data)
    }
    
    func streams(for channelId: String, continuation: String?) async throws -> Channel.VideosResponse {
        guard let idPath = channelId.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) else {
            throw APIError.urlCreation
        }
        let (data, _) = try await request(for: "/api/v1/channels/\(idPath)/streams")
        do {
            return try decoder.decode(Channel.VideosResponse.self, from: data)
        } catch {
            throw error
        }
    }
    
    func playlists(for channelId: String, continuation: String?) async throws -> Channel.PlaylistResponse {
        guard let idPath = channelId.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) else {
            throw APIError.urlCreation
        }
        let (data, _) = try await request(for: "/api/v1/channels/\(idPath)/playlists")
        return try decoder.decode(Channel.PlaylistResponse.self, from: data)
    }
}
